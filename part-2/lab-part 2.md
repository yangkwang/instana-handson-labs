# Part 2. Core Capabilities & Use Cases

## Lab 2.1 – A Quick Tour

A good way to learn new things is to say “hello” to it, with a quick tour.

**Key Concepts**

Deployment pattern
Instana offers full flexibility in terms of deployment: SaaS, or on-prem.

Tenant Unit (TU)
Instana is designed for multi-tenancy. Each Instana installation supports multiple tenants with each tenant consisting of one or multiple tenant units (TU). Please note that multi-tenancy support is only available on SaaS or on-prem when deploying on Kubernetes / OpenShift.

Guided Tour
Instana provides a “guided tour” here: https://play-with.instana.io. Through it you can quickly walk Instana through too in your pace.

Goal
- To quickly walk through what functionalities Instana offers and how Instana organizes them
- To understand how Instana is designed from an end-user perspective

Steps
1. Landing page
The URL for “normal” tenant, other than those “special” ones like “play-with”,
will be structured like: https://<Tenant Unit>-<Tenant Instance>.instana.io

Once we’ve logged into it and we can see the landing page, where it’s the
default dashboard with below information:
- The list of “Websites & Mobile Apps”
- The list of “Application”
- The list of “Kubernetes” clusters
- The list of “Infrastructure”
- The list of “Events”

Please note though, the landing page of the “default” dashboard can be set to your custom dashboard too if you want, so you can have a landing page from that.

<picture>
  <img alt="image3" src="./assets/images/defaultDashboard.png">
</picture>


2. Menu items

<picture>
  <img alt="image3" src="./assets/images/menus.png">
</picture>

3. Commonly shared components

Instana provides a consistent UX and there are some reusable components on different UIs.

<picture>
  <img alt="image3" src="./assets/images/consistentUX.png">
</picture>

Let’s go through some of them one by one:

<picture>
  <img alt="image3" src="./assets/images/UX2.png">
</picture>

**Takeaways**

As you could see from this lab, Instana provides a fine-grained, simplified and consistent user experience while offering highly integrated modern Application Performance Management (APM) features.

We will focus on its core capabilities to dive deeper throughout the labs, one by one.


# Lab 2.2 – Website Monitoring

Instana supports website monitoring by analyzing actual browser request times and route loading times. This allows detailed insights into the web browsing experience of end-users, as well as deep visibility into application call paths. The Instana website monitoring solution works by means of a lightweight JavaScript agent which is embedded into the monitored website.

**Key Concepts**

End-User Monitoring (EUM) or Real-User Monitoring (RUM)
Website monitoring, often called End-User Monitoring (EUM) or Real-User Monitoring (RUM), is an important tool to understand digital user experience.

Goal
- To understand how to enable monitoring for (microservices-based) website
- To walk through the built-in dashboards and metrics
- To understand the value of website monitoring

Steps

1. Start by defining a website on Instana

<picture>
  <img alt="image3" src="./assets/images/defineWebsite.png">
</picture>

Key in the website name, like “Student-{n} Robot Shop Website” is fine, where the {n} is the trainee’s identifier.
Now Instana will automatically generate some code snippet for us which can be easily embedded into our application.


<picture>
  <img alt="image3" src="./assets/images/codeSnippet.png">
</picture>

Note:
  1. We can always check out this info within the website’s configuration anytime later.
  2. The are some important elements we will use, like the reporting URL and key.


## 2. Install Robot-Shop website

Well, a “website” is simply an application with customer-facing UI, which typically may include multiple services at the backend, with databases for data persistence.
Let’s use the Robot Shop app here, which is a “typical” cloud-native application built with different technologies. It’s maintained by Instana team and the OSS community.


### On Kubernetes (at the manage-to host)

Create the namespace
```sh
kubectl create namespace robot-shop
```

Clone the repo
```sh
git clone https://github.com/instana/robot-shop
```

Then cd into it
```sh
cd robot-shop
```

Deploy it by Helm 3
NOTE: Use the right values generated in website config as the variables
```sh
INSTANA_EUM_REPORTING_URL="https://<Instana Server IP>.nip.io:446/eum/" && \
INSTANA_EUM_KEY="xxxxxxxxxxxxxxxxx" && \
helm install robot-shop K8s/helm \
  --namespace robot-shop \
  --set image.version=2.1.0 \
  --set nodeport=true \
  --set eum.url="${INSTANA_EUM_REPORTING_URL}" \
  --set eum.key="${INSTANA_EUM_KEY}"
```

Note:
1. The “eum.url” and “eum.key” are set to the values generated by the previous step
2. If we updated something for the Helm Chart config, we can use “helm upgrade” with
the updated parameters to update the application.

Check out the pods deployed (wait 5-8 min)
```sh
kubectl get pod -n robot-shop
```

<picture>
  <img alt="image3" src="./assets/images/robotshopPods.png">
</picture>


Please note that if we use our exposed EUM endpoint at https://<IP>:446/eum/, 
instead of the internal endpoint at http://<IP>:2999, 
there is a small bug in the Robot Shop app around how to inject the “eum.url” at this line of code, when we expose the EUM endpoint at https://<URL>:<port>/eum/ - Stripping the ending slash will cause no data on EUM dashboard in this case:


<picture>
  <img alt="image3" src="./assets/images/robotshopBug.png">
</picture>


To fix bug in Robot Shop
Firstly, log into the Web Pod:

```sh
kubectl exec -n robot-shop -it "`kubectl get pod -l service=web -n robot-shop -o jsonpath={..metadata.name}`"  -- bash
```

Then print out the eum.url injected eum.html file:

```sh
cat /usr/share/nginx/html/eum.html
```

The content will look like this:

<picture>
  <img alt="image3" src="./assets/images/catContent.png">
</picture>

Let’s copy the content and paste it into your editor of choice, 
and add the tailing “/” at the end of the 'reportingUrl', from:

```sh
From ineum('reportingUrl', 'https://<Instana Server IP>.nip.io:446/eum');
To ineum('reportingUrl', 'https://<Instana Server IP>.nip.io:446/eum/');
```

Then write it back to replace the original eum.html file. 
Please note that there is no “vi” in this Pod 
so we use “cat” command to write back the file:

```sh
cat > /usr/share/nginx/html/eum.html
```

Then copy and paste the updated content to the prompt, 
and then press “Control + c” and the file will be updated.
```sh
<!-- EUM include -->
<script> 
 (function(s,t,a,n){s[t]||(s[t]=a,n=s[a]=function(){n.q.push(arguments)}, 
 n.q=[],n.v=2,n.l=1*new Date)})(window,"InstanaEumObject","ineum");

 ineum('reportingUrl', 'https://<Instana Server IP>.nip.io:446/eum/'); 
 ineum('key', '<key>'); 
 ineum('trackSessions');
 ineum('page', 'splash');
</script>
<script defer crossorigin="anonymous" src="https://<Instana Server IP>.nip.io:446/eum/eum.min.js"></script>
<!-- EUM include end -->
```

You may have a final check by this command and make sure 
there is a ending slash in the 'reportingUrl'
```sh
cat /usr/share/nginx/html/eum.html
```

Please note that we actually don’t need to access the app directly from your browser, especially when you access your VM through another bastion VM. But if you want to expose the newly deployed application in “Kind”-powered cluster for external access, there are some ways (e.g. Ingress with dedicated ports declared while “kind” is provisioned, as documented in official docs here), but exposing it by using a “socat” might be the simplest way to achieve.


Expose the app if you want – this is optional for the lab
Open a terminal

Install socat
```sh
sudo apt-get update
sudo apt-get install socat
```
Get an IP address of the worker node
```sh
kubectl get node -o wide
```
Use any one of the worker node IP for node-ip.

```sh
kubectl get svc -n robot-shop
```

Get the nodeport for web service, node-port.
Open another terminal to run the following command. The terminal needs to be kept there if you want to browse the app.
```sh
socat TCP4-LISTEN:80,fork TCP4: <node-ip>:<node-port>

```

```sh
Now, you can access robotshop via http://<Manage To IP >
```

<picture>
  <img alt="image3" src="./assets/images/robotShop.png">
</picture>


## 3. Install the “load-gen” app

The Robot Shop repository comes with a handy load generation tool to keep accessing the website. We can install that to generate some traffic.

Deploy the load-gen App
```sh
kubectl -n robot-shop apply -f - <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: load
  labels:
    service: load
spec:
  replicas: 1
  selector:
    matchLabels:
      service: load
  template:
    metadata:
      labels:
        service: load
    spec:
      containers:
      - name: load
        env:
          - name: HOST
            value: "http://web:8080/"
          - name: NUM_CLIENTS
            value: "5"
          - name: SILENT
            value: "1"
          - name: ERROR
            value: "0"                  # disable the error calls first
        image: robotshop/rs-load:latest
EOF
```
Bright Zheng created a new Selenium-based “load-gen”, here, which might generate better traffic for website monitoring as it can better simulate the human behaviours for website exploring with the EUM agent executed automatically.

For this lab, please deploy the Selenium-based “load-gen” as well, we can do this:

Deploy the Selenium-based EUM friendly load-gen
```sh
kubectl -n robot-shop apply -f - <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rs-website-load
  labels:
    service: rs-website-load
spec:
  replicas: 1
  selector:
    matchLabels:
      service: rs-website-load
  template:
    metadata:
      labels:
        service: rs-website-load
    spec:
      containers:
      - name: rs-website-load
        env:
          - name: HOST
            value: "http://web:8080/"
        image: brightzheng100/rs-website-load:2.1.0
        imagePullPolicy: Always
EOF
```

To stop the Selenium-based load, it can be scale down by:
```sh 
kubectl scale deployment rs-website-load -n robot-shop --replicas=0
```

## 4. Explore the website monitoring in Instana

Summary tab

<picture>
  <img alt="image3" src="./assets/images/summaryTab.png">
</picture>

Speed tab

<picture>
  <img alt="image3" src="./assets/images/speedTab.png">
</picture>

Resources Tab

<picture>
  <img alt="image3" src="./assets/images/resourceTab.png">
</picture>

HTTP Requests tab

<picture>
  <img alt="image3" src="./assets/images/httpRequestTab.png">
</picture>

JS Errors tab

<picture>
  <img alt="image3" src="./assets/images/jsErrorTab.png">
</picture>

Geography tab

<picture>
  <img alt="image3" src="./assets/images/geoTab.png">
</picture>

Custom Events Tab

<picture>
  <img alt="image3" src="./assets/images/customEventTab.png">
</picture>

Pages tab

<picture>
  <img alt="image3" src="./assets/images/pagesTab.png">
</picture>

Alerts tab

<picture>
  <img alt="image3" src="./assets/images/alertsTab.png">
</picture>

Configuration tab

<picture>
  <img alt="image3" src="./assets/images/configTab.png">
</picture>

**Takeaways**

As you could see from this lab, Instana can help us generate a handy code snippet with the fine-grained EUM JavaScript Agent embedded, which can be easily plugged into our app to make it instrumented.
The built-in website monitoring dashboard can be used to capture and visualize the metrics as the golden signals for our app SRE/operator to understand the website’s performance with a true End-User Monitoring (EUM) or Real-User Monitoring (RUM) experience.


# Lab 2.3 – Install & Manage Agents
Agent is the piece of software deployed into the monitored environment so that it can discover and collect the right monitoring data and send it back to Instana backend for further correlation and analytics for insights and actions.

**Key Concepts**

Instana has a powerful “one-agent” concept, which means that one agent discovers all supported technologies intelligently, activates the right sensor(s) to collect the right data, and sends it over to the backend. However, this
doesn’t mean one-size-fits-all. Instead, Instana offers some “higher” level of
agent types.

**Agent Types**

- Host Agents are agents installed into a Virtual Machine (VM), a physical host, Kubernetes, Cloud Foundry, VMware Tanzu and similar platforms.
- Cloud Service Agents are agents installed to monitor Cloud providers, like Amazon Relational Database Service (RDS) or Azure subscriptions.
- Serverless Agents are agents extend corresponding Cloud Service Agents for monitoring serverless – also known as Function-as-a-Service (FaaS) or Container-as-a-Service (CaaS) – platforms. As of now, AWS Fargate, AWS Lambda, Google Cloud Run are supported.
- Web and Mobile Agents are agents used for monitoring web sites and mobile applications.

**Goal**

1. To understand the agent types Instana provides for different monitor targets
2. To learn how to install agents on Kubernetes/OpenShift and Linux VM
3. To dive deeper into Instana’s Agent architecture, sensors and management

**Steps**

In general, Instana provides convenient mechanisms to generate installation scripts for all types of agents.

Click “Agents” -> “Installing Instana Agents” to start with:

<picture>
  <img alt="image3" src="./assets/images/installAgent.png">
</picture>

<picture>
  <img alt="image3" src="./assets/images/installAgent2.png">
</picture>


## 1. Kubernetes agent – Generate installation scripts

Click “Kubernetes”, pick “Helm chart”, which is the default option, and key in:

- Cluster name: it’s a cluster name of the Kubernetes, e.g. “Student-{n}- Cluster” is fine, where {n} is the trainee’s identifier

- Agent zone: it’s a logical “zone” concept to group your resources in “Infrastructure” view, e.g. “Student-{n}-Zone” is fine, where {n} is the trainee’s identifier – please pick a meaningful name for the zone.

<picture>
  <img alt="image3" src="./assets/images/k8sAgent.png">
</picture>

And then click the “Copy” button to copy the generated script to clipboard.

## 2. Kubernetes agent – Install agent

We now can paste the copied script on the console of our Host VM and run it. The script should look like this – do remember to use your generated script!

Make sure we’ve logged into Kubernetes with admin role 
Then past YOUR copied script to install the agent

```sh
helm install instana-agent \
  --repo https://agents.instana.io/helm \ 
  --namespace instana-agent \ 
  --create-namespace \ 
  --set agent.key=xxxxxxxxxxxxxxxxxx \ 
  --set agent.downloadKey=xxxxxxxxxxxxxxxxxx \ 
  --set agent.endpointHost=<Instana Server IP>.nip.io \ 
  --set agent.endpointPort=1444 \ 
  --set cluster.name='Student-1-Cluster' \ 
  --set zone.name='Student-1-Zone' \ 
  instana-agent
```
Note:
  - By default, the Helm command will create a namespace named “instana-agent”.
  - If you’re installing the agent for OpenShift, not Kubernetes, there is another dedicated entry, but the Helm command is quite similar.

If proxy is required to access the backend and the repository of agent sensors, configure below environment variables and set them with “--set key=value” format:

```sh
agent.proxyHost      Hostname/address of a proxy
agent.proxyPort      Port of a proxy
agent.proxyProtocol  Proxy protocol. Supported proxy types are http (for both HTTP and HTTPS proxies), socks4, socks5.
agent.proxyUser      Username of the proxy auth
agent.proxyPassword  Password of the proxy auth
agent.proxyUseDNS    Boolean if proxy also does DNS
```

After a few (1-2) minutes, we should be able to see the pods running, which are derived from a DaemonSet:

Soon, we can see the pods of the DaemonSet are deployed

```sh
kubectl get pod -n instana-agent
```
<picture>
  <img alt="image3" src="./assets/images/k8sPod.png">
</picture>



## 6. Linux VM agent – Install agent

Run this in the Host VM:

```sh
# cd to the home folder
$ cd ~

# List out the footloose-powered VMs we have
$ footloose show -c footloose.yaml

# Log into the Ubuntu VM
$ footloose ssh root@ubuntu-0 -c footloose.yaml
```

Once SSH'ed into the Ubuntu "VM" powered by `footloose`:

```
root@ubuntu-0:~# apt-get update
root@ubuntu-0:~# apt-get install gpg apt-utils -y

root@ubuntu-0:~# curl -o setup_agent.sh https://setup.instana.io/agent && chmod 700 ./setup_agent.sh && sudo ./setup_agent.sh -a xxxxxxxxxxxxxxxxxx -d xxxxxxxxxxxxxxxxxx -t dynamic -e 168.1.53.231.nip.io:1444 -y 
```

```
# By default, the agent is not up and running after installation
root@ubuntu-0:~# systemctl status instana-agent
```

```
# If needed to uninstall the agent
apt list --installed | grep instana-agent
sudo apt-get purge <package_name>

```

```
# Log into the Centos VM
$ footloose ssh root@centos-0 -c footloose.yaml
yum install which

root@ubuntu-0:~# curl -o setup_agent.sh https://setup.instana.io/agent && chmod 700 ./setup_agent.sh && sudo ./setup_agent.sh -a xxxxxxxxxxxxxxxxxx -d xxxxxxxxxxxxxxxxxx -t dynamic -e 168.1.53.231.nip.io:1444 -y
```

```
# Configure zone
root@ubuntu-0:~# touch /opt/instana/agent/etc/instana/configuration-zone.yaml
root@ubuntu-0:~# INSTANA_ZONE="Student-1-Zone" && \
cat <<EOF | sudo tee /opt/instana/agent/etc/instana/configuration-zone.yaml
# Hardware & Zone
com.instana.plugin.generic.hardware:
  enabled: true
  availability-zone: "${INSTANA_ZONE}"
EOF

# (optional) Configure host, like tags
# Do change them accordingly
root@ubuntu-0:~# touch /opt/instana/agent/etc/instana/configuration-host.yaml
root@ubuntu-0:~# cat <<EOF | sudo tee /opt/instana/agent/etc/instana/configuration-host.yaml
# Host
com.instana.plugin.host:
  tags:
    - 'labs'
    - 'poc'
    - 'instana'
EOF
```

```
# Start it up
root@ubuntu-0:~# systemctl enable instana-agent
root@ubuntu-0:~# systemctl start instana-agent

# We can trace the logs too
root@ubuntu-0:~# journalctl -flu instana-agent
```

